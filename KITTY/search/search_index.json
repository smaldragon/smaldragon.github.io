{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is a KITTY? (an introduction) The KITTY (Kewl Interactive Text Terminal sYstem) is a new 8bit 65c02-based fantasy homebrew computer developed by smal (that's me!), it envisions a microcomputer which never existed, with colorful text based graphics, an unique sound system and, oddly, cartridges as its main form of media and expansion. Looking at the back of the system, we see an austere sight: An audio/video SCART port and two cartridge ports, and not a single peripheral port in sight! In fact, the basic cartridge that came bundled with every sold system had to include audio jacks on the cart itself in order to allow one to save their programs. Rather than a failure, this was the driving design philosphy behind the cost-saving design of the KITTY, to allow programs to come bundled with any extra features they might need, while leaving the base design unburdened, after all, what use would an extra port or feature be without an accompaning program to use it? Sadly we do not have access to this particular alternate reality (perhaps because it is imaginary), so we can not judge the success of this particular design approach. However, I have designed and built a version of this system here in our own world for anyone to play with, and this is what this manual is all about. I wish you a fun and (hopefully) educational time exploring this little system The original v0a board prototype Details The current iteration of the KITTY board (v1a) uses only in-production parts and is open hardware that anyone can tweak and build upon, on the v1a board custom features like video and audio are all implemented through the means of discrete 74-series logic. All ICs are in either Dual-In-Line packages or PLCC packages using through hole sockets, so that no surface mount soldering is required for assembly and all ICs can be easily placed or removed. Finally, all components, their values, and their general function within the circuit are written on the silkscreen itself, as I wanted a board that was easy to assemble and understand. SPECS CPU 65c02 @ ~2.2mhz (3mhz bus) RAM 28Kb Static Ram MEDIA 2 cartridge slots for programs or expansion, each with up to 128 banks of 32kb for a theoretical max of 4Mb per cartridge VIDEO Custom, 8x8 pixel characters on a 32x32 grid, selectable background/foreground colors from a pallette of 16 AUDIO Custom, 4 channels of 8x1 wavetable audio (3 melodic, 1 percussive), with 4bit+4bit stereo volume control INPUT Custom 40-key mechanical keyboard OUTPUT SCART, using RGB progressive PAL @50.1hz POWER 5v DC via a center positive barrel jack","title":"Home"},{"location":"#what-is-a-kitty-an-introduction","text":"The KITTY (Kewl Interactive Text Terminal sYstem) is a new 8bit 65c02-based fantasy homebrew computer developed by smal (that's me!), it envisions a microcomputer which never existed, with colorful text based graphics, an unique sound system and, oddly, cartridges as its main form of media and expansion. Looking at the back of the system, we see an austere sight: An audio/video SCART port and two cartridge ports, and not a single peripheral port in sight! In fact, the basic cartridge that came bundled with every sold system had to include audio jacks on the cart itself in order to allow one to save their programs. Rather than a failure, this was the driving design philosphy behind the cost-saving design of the KITTY, to allow programs to come bundled with any extra features they might need, while leaving the base design unburdened, after all, what use would an extra port or feature be without an accompaning program to use it? Sadly we do not have access to this particular alternate reality (perhaps because it is imaginary), so we can not judge the success of this particular design approach. However, I have designed and built a version of this system here in our own world for anyone to play with, and this is what this manual is all about. I wish you a fun and (hopefully) educational time exploring this little system The original v0a board prototype","title":"What is a KITTY? (an introduction)"},{"location":"#details","text":"The current iteration of the KITTY board (v1a) uses only in-production parts and is open hardware that anyone can tweak and build upon, on the v1a board custom features like video and audio are all implemented through the means of discrete 74-series logic. All ICs are in either Dual-In-Line packages or PLCC packages using through hole sockets, so that no surface mount soldering is required for assembly and all ICs can be easily placed or removed. Finally, all components, their values, and their general function within the circuit are written on the silkscreen itself, as I wanted a board that was easy to assemble and understand.","title":"Details"},{"location":"#specs","text":"CPU 65c02 @ ~2.2mhz (3mhz bus) RAM 28Kb Static Ram MEDIA 2 cartridge slots for programs or expansion, each with up to 128 banks of 32kb for a theoretical max of 4Mb per cartridge VIDEO Custom, 8x8 pixel characters on a 32x32 grid, selectable background/foreground colors from a pallette of 16 AUDIO Custom, 4 channels of 8x1 wavetable audio (3 melodic, 1 percussive), with 4bit+4bit stereo volume control INPUT Custom 40-key mechanical keyboard OUTPUT SCART, using RGB progressive PAL @50.1hz POWER 5v DC via a center positive barrel jack","title":"SPECS"},{"location":"assembly/","text":"Phase 1 - Power Barrel Jack Power LED 680\u03a9 led resistor power switch big decoupling capacitor [ ] Check if Power LED turns on [ ] Check Voltage is 5V","title":"Phase 1 - Power"},{"location":"assembly/#phase-1-power","text":"Barrel Jack Power LED 680\u03a9 led resistor power switch big decoupling capacitor","title":"Phase 1 - Power"},{"location":"assembly/#_1","text":"[ ] Check if Power LED turns on [ ] Check Voltage is 5V","title":""},{"location":"audio/","text":"Audio System Address Mode Description Format $70E0 R/W Channel 1 Frequency %cccc_cccc c ounter value $70E0 R/W Channel 2 Frequency %cccc_cccc c ounter value $70E0 R/W Channel 3 Frequency %cccc_cccc c ounter value $70E3 R/W Frequency Control Register %ssffmmmd (see frequency section) $70F0 W Channel 1 Volume %llll_rrrr l eft and r ight volume $70F1 W Channel 2 Volume %llll_rrrr l eft and r ight volume $70F2 W Channel 3 Volume %llll_rrrr l eft and r ight volume $70F3 W Channel 4 Volume %llll_rrrr l eft and r ight volume $70F4 W Channel 1 Waveform %wwww_wwww 8x1 w aveform $70F5 W Channel 2 Waveform %wwww_wwww 8x1 w aveform $70F6 W Channel 3 Waveform %wwww_wwww 8x1 w aveform $70F7 W Channel 4 Waveform %wwww_wwww 8x1 w aveform The KITTY provides a custom and unique sound system capable of generating chiptune music and sound effects. It is a wavetable synth (using a measly 8x1 resolution), with stereo volume control (4bit+4bit), and 4 sound channels (3 melodic and 1 percursive). Setting the volume The volume registers ( $70F0-$70F3 ) allow you to set the current volume of each channel for both the left and right audio speakers. Volume is defined by a writing single byte to the register, where the upper nibble sets the volume for the left speaker and the lower nibble the right channel. By writing different volume values on every frame the programmer can achieve smooth volume envelopes and panning effects. For example, the value $F8 would output a wave at max value on the left speaker and at half volume on the right. In hardware 2 74hc670 4x4bit registers hold the left and right volumes of each channel, and are each connected to one of the two left/right audio DACs. Setting a Waveform The waveform registers ( $70F4-$70F7 ) allow you to set the \"timbre\" to be used by each channel. The waveform is defined by writing a single byte to the register, where each bit is interpreted as either a low (0) or high (1) on the waveform. For example, writing the value $F0 ( %11110000 ) would create a simple square wave, while $C0 ( %11000000 ) would generate a 25% duty pulse wave. By playing around with values its possible to make a wide array of interesting sounds: In hardware 4 74hc165 shift-registers hold each waveform and are clocked in a self-feeding fashion in order to produce a note. Setting the Frequency (Channels 1-3) The frequency of the melodic channels (1-3) are controlled by a 82c54 triple timer addressable at $70E0-$70E3 , this is a chip also found in the original IBM PC, where it is used to control its beeper (along with other non-sound functions). Its programming is a bit more complex compared to the other sound registers, but I will try and explain it here as best I can. Before setting the frequency for any of the melodic channels, one must first write to the frequency control register ( $70E3 ), to configure the action to perform (this must be done whenever you want to set a new frequency): 7 bit 0 ---- ---- SSFFMMMD | | | | | | | |- decimal: | | | 0: binary; 1: binary coded decimal | | | | | |- mode: | | 000: interrupt on terminal count | | 001: hardware one-shot | | 010: rate generator | | 011: square wave | | 100: software strobe | | 101: hardware strobe | | | |- format: | 00: latch counter value, 01: r/w low byte, 10: r/w high byte, 11 r/w low then high bytes | ---- Register Selection (0-3) Most of these options are not useful for our purpose, typically the configuration used will be format: 11 (16-bit r/w), mode: 010 (rate generator), decimal: 0 (binary mode), or %xx110100 ( $34 + $xx ), where the top 2 bits are the register to operate on. The final frequency of each channel is then derived from the division of a 3Mhz base clock by the counter's 16-bit value, divided by the length of the wavetable (8 steps): frequency = 3Mhz / counter n / 8 Example: # Setting a frequency for channel 1 (CapyASM syntax) # first set the control register, for channel 0 lda %00 + $34 sta [$70E3] # now write a new frequency value ($9340) lda $40 sta [$70E0] lda $93 sta [$70E0] NOTE: A counter value of 0 is equivalent to 65536, while a counter value of 1 is illegal and should not be used. The Percussive Channel (channel 4) Unlike the first 3 \"melodic\" channels, channel 4 lacks frequency control, and instead uses a fixed frequency of 50hz, which is synchronized with the video circuit. By carefully writing new wavetable values to this register once per frame (when the screen IRQ is called), it is thus possible to generate simple percussive sounds like white noise and drums.","title":"Audio"},{"location":"audio/#audio-system","text":"Address Mode Description Format $70E0 R/W Channel 1 Frequency %cccc_cccc c ounter value $70E0 R/W Channel 2 Frequency %cccc_cccc c ounter value $70E0 R/W Channel 3 Frequency %cccc_cccc c ounter value $70E3 R/W Frequency Control Register %ssffmmmd (see frequency section) $70F0 W Channel 1 Volume %llll_rrrr l eft and r ight volume $70F1 W Channel 2 Volume %llll_rrrr l eft and r ight volume $70F2 W Channel 3 Volume %llll_rrrr l eft and r ight volume $70F3 W Channel 4 Volume %llll_rrrr l eft and r ight volume $70F4 W Channel 1 Waveform %wwww_wwww 8x1 w aveform $70F5 W Channel 2 Waveform %wwww_wwww 8x1 w aveform $70F6 W Channel 3 Waveform %wwww_wwww 8x1 w aveform $70F7 W Channel 4 Waveform %wwww_wwww 8x1 w aveform The KITTY provides a custom and unique sound system capable of generating chiptune music and sound effects. It is a wavetable synth (using a measly 8x1 resolution), with stereo volume control (4bit+4bit), and 4 sound channels (3 melodic and 1 percursive).","title":"Audio System"},{"location":"audio/#setting-the-volume","text":"The volume registers ( $70F0-$70F3 ) allow you to set the current volume of each channel for both the left and right audio speakers. Volume is defined by a writing single byte to the register, where the upper nibble sets the volume for the left speaker and the lower nibble the right channel. By writing different volume values on every frame the programmer can achieve smooth volume envelopes and panning effects. For example, the value $F8 would output a wave at max value on the left speaker and at half volume on the right. In hardware 2 74hc670 4x4bit registers hold the left and right volumes of each channel, and are each connected to one of the two left/right audio DACs.","title":"Setting the volume"},{"location":"audio/#setting-a-waveform","text":"The waveform registers ( $70F4-$70F7 ) allow you to set the \"timbre\" to be used by each channel. The waveform is defined by writing a single byte to the register, where each bit is interpreted as either a low (0) or high (1) on the waveform. For example, writing the value $F0 ( %11110000 ) would create a simple square wave, while $C0 ( %11000000 ) would generate a 25% duty pulse wave. By playing around with values its possible to make a wide array of interesting sounds: In hardware 4 74hc165 shift-registers hold each waveform and are clocked in a self-feeding fashion in order to produce a note.","title":"Setting a Waveform"},{"location":"audio/#setting-the-frequency-channels-1-3","text":"The frequency of the melodic channels (1-3) are controlled by a 82c54 triple timer addressable at $70E0-$70E3 , this is a chip also found in the original IBM PC, where it is used to control its beeper (along with other non-sound functions). Its programming is a bit more complex compared to the other sound registers, but I will try and explain it here as best I can. Before setting the frequency for any of the melodic channels, one must first write to the frequency control register ( $70E3 ), to configure the action to perform (this must be done whenever you want to set a new frequency): 7 bit 0 ---- ---- SSFFMMMD | | | | | | | |- decimal: | | | 0: binary; 1: binary coded decimal | | | | | |- mode: | | 000: interrupt on terminal count | | 001: hardware one-shot | | 010: rate generator | | 011: square wave | | 100: software strobe | | 101: hardware strobe | | | |- format: | 00: latch counter value, 01: r/w low byte, 10: r/w high byte, 11 r/w low then high bytes | ---- Register Selection (0-3) Most of these options are not useful for our purpose, typically the configuration used will be format: 11 (16-bit r/w), mode: 010 (rate generator), decimal: 0 (binary mode), or %xx110100 ( $34 + $xx ), where the top 2 bits are the register to operate on. The final frequency of each channel is then derived from the division of a 3Mhz base clock by the counter's 16-bit value, divided by the length of the wavetable (8 steps): frequency = 3Mhz / counter n / 8 Example: # Setting a frequency for channel 1 (CapyASM syntax) # first set the control register, for channel 0 lda %00 + $34 sta [$70E3] # now write a new frequency value ($9340) lda $40 sta [$70E0] lda $93 sta [$70E0] NOTE: A counter value of 0 is equivalent to 65536, while a counter value of 1 is illegal and should not be used.","title":"Setting the Frequency (Channels 1-3)"},{"location":"audio/#the-percussive-channel-channel-4","text":"Unlike the first 3 \"melodic\" channels, channel 4 lacks frequency control, and instead uses a fixed frequency of 50hz, which is synchronized with the video circuit. By carefully writing new wavetable values to this register once per frame (when the screen IRQ is called), it is thus possible to generate simple percussive sounds like white noise and drums.","title":"The Percussive Channel (channel 4)"},{"location":"cartridge/","text":"Cartridges and Memory Address Mode Description Format $0000-$6FFF R/W System Ram 28Kb of static ram $70D0 W BANK Register %cccc_bbbb c artridge 0-1 and b ank 0-127 $8000-$FFFF R/W Cartridge Space 32Kb banked window Cartridges are the main form of media and expansion used by the KITTY, with the system being able to hold 2 cartridges at a time (dubbed Slot 1 and Slot 2), each of which have an individual 4Mb address space, that can be filled with programs, extra ram or peripheral devices. They are accessed through the upper half of the KITTY memory map ( $8000-$FFFF ), which acts as 32Kb window into the contents of one of the 2 carts. This window can then be controlled by writing to the BANK register located at $70D0 . The upper bit will determine the cartridge, while the 7 remaining bits will select one of up to 128 banks within it. Finally, on hardware reset/power-on the BANK register will always be cleared to $00. As such, CPU will always begin code execution from the Bank 0 of Slot 1. OS ROM The \"OS ROM\" or \"TEST ROM\" is a rom present on the main KITTY PCB, which is virtuaslly mapped to cartridge Slot 1. As of time of writing (2024-01-05), the contents of this chip have not been defined. Cartridge Pinout The 2 cartridge slots use standard right-angle edge connectors, with 44-pins, and a spacing of 2.54mm (0.1\"): D0-D7 - 8bit data bus A0-A15 - 16bit address bus B0-B7 - 8bit BANK register M3 - 3Mhz Bus Clock R/#W - Read/Write Signal, standard 65xx polarity #R/W - Read/Write Signal, inverted polarity #RESET - System Reset #NMI - Non-Maskable Interrupt #CART - Cartridge Space Access A15 NAND M3 #SLOT ENABLE - If the current slot is enabled (according to bit 7 of BANK) ROM DISABLE - Disable OS ROM (slot 1 only) x - Unconnected ROM DISABLE is a signal that, when pulled high by a cartridge in Slot 1, disables the OS ROM. A cart can choose to leave this signal permanently high, to completely replace the OS ROM, or it can instead choose to implement more complex address decoding logic, allowing both to coexist within the same slot.","title":"Cartridges and Memory"},{"location":"cartridge/#cartridges-and-memory","text":"Address Mode Description Format $0000-$6FFF R/W System Ram 28Kb of static ram $70D0 W BANK Register %cccc_bbbb c artridge 0-1 and b ank 0-127 $8000-$FFFF R/W Cartridge Space 32Kb banked window Cartridges are the main form of media and expansion used by the KITTY, with the system being able to hold 2 cartridges at a time (dubbed Slot 1 and Slot 2), each of which have an individual 4Mb address space, that can be filled with programs, extra ram or peripheral devices. They are accessed through the upper half of the KITTY memory map ( $8000-$FFFF ), which acts as 32Kb window into the contents of one of the 2 carts. This window can then be controlled by writing to the BANK register located at $70D0 . The upper bit will determine the cartridge, while the 7 remaining bits will select one of up to 128 banks within it. Finally, on hardware reset/power-on the BANK register will always be cleared to $00. As such, CPU will always begin code execution from the Bank 0 of Slot 1.","title":"Cartridges and Memory"},{"location":"cartridge/#os-rom","text":"The \"OS ROM\" or \"TEST ROM\" is a rom present on the main KITTY PCB, which is virtuaslly mapped to cartridge Slot 1. As of time of writing (2024-01-05), the contents of this chip have not been defined.","title":"OS ROM"},{"location":"cartridge/#cartridge-pinout","text":"The 2 cartridge slots use standard right-angle edge connectors, with 44-pins, and a spacing of 2.54mm (0.1\"): D0-D7 - 8bit data bus A0-A15 - 16bit address bus B0-B7 - 8bit BANK register M3 - 3Mhz Bus Clock R/#W - Read/Write Signal, standard 65xx polarity #R/W - Read/Write Signal, inverted polarity #RESET - System Reset #NMI - Non-Maskable Interrupt #CART - Cartridge Space Access A15 NAND M3 #SLOT ENABLE - If the current slot is enabled (according to bit 7 of BANK) ROM DISABLE - Disable OS ROM (slot 1 only) x - Unconnected ROM DISABLE is a signal that, when pulled high by a cartridge in Slot 1, disables the OS ROM. A cart can choose to leave this signal permanently high, to completely replace the OS ROM, or it can instead choose to implement more complex address decoding logic, allowing both to coexist within the same slot.","title":"Cartridge Pinout"},{"location":"interrupt/","text":"Interrupts On the 65c02, vectors are a series of 16-bit addresses located at the very top of memory, that provide to the processor the location of a subroutine to execute whenever a given external hardware signal is received. Interrupt Address IRQ $FFFE-$FFFF BRK $FFFE-$FFFF RESET $FFFC-$FFFD NMI $FFFA-$FFFB Interrupts subroutines operate very similarly to regular subroutines, but are exit through a RTI instruction instead of RTS . RESET - Reset The 65c02, like most other CPU architectures, utilizes a RESET signal in order to initialize the processor to a known and stable starting state. On the KITTY, this signal is triggered on power-up, as well as when the user manually presses the reset button. Reset utilizes the vector at $FFFC-$FFFD , additionally, it also clears the BANK register to $00 , meaning that code execution on the KITTY will always start at bank 0 of cart 0. IRQ - Interrupt Request The KITTY possesses a single 50hz IRQ interrupt that is generated by the video circuit's signal ROM, whenever the last visible pixel on a given frame is drawn to the screen. It utilizes the vector at $FFFE-$FFFF . This signal is the main method of keeping time on the system, allowing for code to run at a predictable pace, essential for the update loops of many programs and games. IRQ can be optionally disabled or enabled by the CPU at any time through the use of the SEI and CLI instructions, respectively. Note that on reset, IRQs will always be disabled, so the programmer must remember to enable them if they wish to make use of this feature. WAI - Wait for Interrupt The 65c02 designed by the Western Design Center, introduced a new \"Wait for Interrupt\" Instruction ( WAI ), that as implied by the name, causes the CPU to \"Wait\" in place until awaken by an interrupt. While this instruction achieves a similar function as to what waiting on a infinite loop in older 65x processors would, it also has an additional and very useful quirk: when an IRQ is triggered while Interrupts are disabled, the Wait state will end and execution will move on to the next instruction, bypassing the Interrupt Vector and associated routine entirely, and reacting within a single clock cycle. This can allow for code that is a lot more flexible, faster, and pleasant to write. NMI - Non-maskable Interrupt The NMI, non-maskable interrupt, operates very similarly to IRQ, except that it can not be disabled in software. It uses the vector at $FFFA-$FFFB . On a vanilla KITTY, there is no hardware that generates this interrupt, but it is avaliable on the cartridge ports for use by potential peripheral expansions. BRK - Break BRK is a software triggered interrupt, which shares the same Vector as IRQ ( $FFFE-$FFFF ). It can be distinguished from an IRQ by checking if the B bit (4th bit) on the processor status register, that was pushed to the stack, was set to 1. BRK is a two-byte instruction, with the second byte being unused and having no effect, however some assemblers might allow for this extra byte to be set to an arbitrary given value. Overall, BRK is rarely used in software, but is described here for the sake of completion.","title":"Interrupts"},{"location":"interrupt/#interrupts","text":"On the 65c02, vectors are a series of 16-bit addresses located at the very top of memory, that provide to the processor the location of a subroutine to execute whenever a given external hardware signal is received. Interrupt Address IRQ $FFFE-$FFFF BRK $FFFE-$FFFF RESET $FFFC-$FFFD NMI $FFFA-$FFFB Interrupts subroutines operate very similarly to regular subroutines, but are exit through a RTI instruction instead of RTS .","title":"Interrupts"},{"location":"interrupt/#reset-reset","text":"The 65c02, like most other CPU architectures, utilizes a RESET signal in order to initialize the processor to a known and stable starting state. On the KITTY, this signal is triggered on power-up, as well as when the user manually presses the reset button. Reset utilizes the vector at $FFFC-$FFFD , additionally, it also clears the BANK register to $00 , meaning that code execution on the KITTY will always start at bank 0 of cart 0.","title":"RESET - Reset"},{"location":"interrupt/#irq-interrupt-request","text":"The KITTY possesses a single 50hz IRQ interrupt that is generated by the video circuit's signal ROM, whenever the last visible pixel on a given frame is drawn to the screen. It utilizes the vector at $FFFE-$FFFF . This signal is the main method of keeping time on the system, allowing for code to run at a predictable pace, essential for the update loops of many programs and games. IRQ can be optionally disabled or enabled by the CPU at any time through the use of the SEI and CLI instructions, respectively. Note that on reset, IRQs will always be disabled, so the programmer must remember to enable them if they wish to make use of this feature.","title":"IRQ - Interrupt Request"},{"location":"interrupt/#wai-wait-for-interrupt","text":"The 65c02 designed by the Western Design Center, introduced a new \"Wait for Interrupt\" Instruction ( WAI ), that as implied by the name, causes the CPU to \"Wait\" in place until awaken by an interrupt. While this instruction achieves a similar function as to what waiting on a infinite loop in older 65x processors would, it also has an additional and very useful quirk: when an IRQ is triggered while Interrupts are disabled, the Wait state will end and execution will move on to the next instruction, bypassing the Interrupt Vector and associated routine entirely, and reacting within a single clock cycle. This can allow for code that is a lot more flexible, faster, and pleasant to write.","title":"WAI - Wait for Interrupt"},{"location":"interrupt/#nmi-non-maskable-interrupt","text":"The NMI, non-maskable interrupt, operates very similarly to IRQ, except that it can not be disabled in software. It uses the vector at $FFFA-$FFFB . On a vanilla KITTY, there is no hardware that generates this interrupt, but it is avaliable on the cartridge ports for use by potential peripheral expansions.","title":"NMI - Non-maskable Interrupt"},{"location":"interrupt/#brk-break","text":"BRK is a software triggered interrupt, which shares the same Vector as IRQ ( $FFFE-$FFFF ). It can be distinguished from an IRQ by checking if the B bit (4th bit) on the processor status register, that was pushed to the stack, was set to 1. BRK is a two-byte instruction, with the second byte being unused and having no effect, however some assemblers might allow for this extra byte to be set to an arbitrary given value. Overall, BRK is rarely used in software, but is described here for the sake of completion.","title":"BRK - Break"},{"location":"keyboard/","text":"Keyboard The KITTY uses a custom 40-key mechanical keyboard for input, which is connected to the main board via two cables. The keyboard can be read directly by the cpu through means of 5 Keyboard Row Registers, where each bit in the byte represents the current state of a particular key ( 0 =unpressed 1 =pressed). Address Mode Description Format (bit 7-0) $7000 R Keyboard Row 1 O I U T R E W Esc $7010 R Keyboard Row 2 P K J Y G S Q Alt $7020 R Keyboard Row 3 Backspace L M H V D A Shift $7030 R Keyboard Row 4 Enter . | N B F Z Menu $7040 R Keyboard Row 5 \u2192 \u2193 \u2190 \u2191 Space C X Ctrl","title":"Keyboard"},{"location":"keyboard/#keyboard","text":"The KITTY uses a custom 40-key mechanical keyboard for input, which is connected to the main board via two cables. The keyboard can be read directly by the cpu through means of 5 Keyboard Row Registers, where each bit in the byte represents the current state of a particular key ( 0 =unpressed 1 =pressed). Address Mode Description Format (bit 7-0) $7000 R Keyboard Row 1 O I U T R E W Esc $7010 R Keyboard Row 2 P K J Y G S Q Alt $7020 R Keyboard Row 3 Backspace L M H V D A Shift $7030 R Keyboard Row 4 Enter . | N B F Z Menu $7040 R Keyboard Row 5 \u2192 \u2193 \u2190 \u2191 Space C X Ctrl","title":"Keyboard"},{"location":"power/","text":"","title":"Power"},{"location":"sample/","text":"A Sample Program","title":"A Sample Program"},{"location":"sample/#a-sample-program","text":"","title":"A Sample Program"},{"location":"video/","text":"Video System The KITTY's video output is a text based display containing 32 by 32 tiles of 8 by 8 pixels. Each tile can be set to one of 256 different characters from a fixed font, with foreground and background colors chosen from a palette of 16. The data for the display is located directly in system ram: Address Description Format $6800-$6BFF Display Color %ffff_bbbb f oreground and b ackground $6C00-$6FFF Display Characters 0-255 extended ascii character Palette An approximation of the KITTY's color palette: Font The font is a variation of ascii: Details The color palette is generated from the following resistor DAC:","title":"Video"},{"location":"video/#video-system","text":"The KITTY's video output is a text based display containing 32 by 32 tiles of 8 by 8 pixels. Each tile can be set to one of 256 different characters from a fixed font, with foreground and background colors chosen from a palette of 16. The data for the display is located directly in system ram: Address Description Format $6800-$6BFF Display Color %ffff_bbbb f oreground and b ackground $6C00-$6FFF Display Characters 0-255 extended ascii character","title":"Video System"},{"location":"video/#palette","text":"An approximation of the KITTY's color palette:","title":"Palette"},{"location":"video/#font","text":"The font is a variation of ascii:","title":"Font"},{"location":"video/#details","text":"The color palette is generated from the following resistor DAC:","title":"Details"}]}